infranodes:
  enabled: true
clusterlogging:
  managementState: "Managed"
lokistack:
  # Aktiviert die Ruler Komponente um aufgrund von Logfiles Alerts abschicken zu können.
  rules:
    enabled: true
  minio:
    enabled: false
  configuration:
    storageClassName: rook-ceph-fs
    limits:
      ingestion:
        # not entirely clear what does values do, but apparently they fix the ingestionRateLimit error inside of the log
        # collectors
        ingestionRate: 200
        ingestionBurstSize: 150
      queries:
        maxChunksPerQuery: 4000000
        maxQueriesSeries: 1000
    size: 1x.small  # Valid values are: 1x.extra-small, 1x.small, 1x.medium
    compactor:
      replicas: 1
    distributor:
      replicas: 1
    gateway:
      replicas: 1
    indexGateway:
      replicas: 1
    ingester:
      replicas: 1
    querier:
      replicas: 2
    queryFrontend:
      replicas: 1
    ruler:
      replicas: 1
  backend:
    bucketname: loki
    accesskey: loki
    secretkey: ""
    endpoint: "http://loki-backend-storage.openshift-logging.svc.cluster.local:9000/"

# Sollte später über die NetApp direkt geregelt werden.
# bitnami minio chart
minio:
  existingSecret: "loki-backend-secret"
  podSecurityContext:
    enabled: true
    fsGroup: 1001
  containerSecurityContext:
    enabled: true
    runAsUser: 1001
    runAsNonRoot: true
  fullnameOverride: loki-backend-storage
  replicas: 1
  persistence:
    size: 200Gi
  resources:
    requests:
      memory: 2Gi #default 4Gi bei 500Gi persistent storage. Sollte mit weniger auch auskommen.
    limits:
      memory: 4Gi
  makeBucketJob:
    securityContext:
      enabled: true
      runAsUser: 0
  defaultBucket:
    enabled: true
    name: loki
  serviceAccount:
    name: loki-minio